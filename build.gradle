import net.fabricmc.mappingio.*
import net.fabricmc.mappingio.adapter.*
import net.fabricmc.mappingio.format.*
import net.fabricmc.mappingio.tree.*

buildscript {
    repositories {
        maven {
            name "Fabric Repository"
            url 'https://maven.fabricmc.net'
        }
    }

    dependencies {
        classpath 'net.fabricmc:mapping-io:0.6.1'
    }
}

plugins {
    id 'maven-publish'
}

def ENV = System.getenv()

file("mappings").eachDir { dir ->

    def mcVersion = dir.name
    def buildDir = new File(layout.buildDirectory.asFile.get(), "mappings/" + dir.name)
    buildDir.mkdirs()

    def artifactVersion = mcVersion
    if (ENV.GITHUB_REF_NAME)
        artifactVersion += "+" + ENV.GITHUB_REF_NAME

    project.logger.lifecycle("Building ${artifactVersion}")

    def v1MappingFile = new File(dir, "mappings.tiny")
    def v2MappingFile = new File(buildDir, "v1.tiny")
    def v1UpstreamedMappingFile = new File(buildDir, "v1-upstream.tiny")
    def v2UpstreamedMappingFile = new File(buildDir, "v2-upstream.tiny")

    def conversionTask = tasks.register("${mcVersion}_convertToV2") {
        group = "V2 Conversion"
        inputs.file(v1MappingFile)
        outputs.file(v2MappingFile)

        doLast {
            def memoryMappingTree = new MemoryMappingTree()
            def nsCompleter = new MappingNsCompleter(memoryMappingTree, Map.of("glue", "intermediary", "server", "intermediary", "client", "intermediary"));
            MappingReader.read(v1MappingFile.toPath(), nsCompleter)
            try (def mappingWriter = MappingWriter.create(v2MappingFile.toPath(), MappingFormat.TINY_2_FILE)) {
                memoryMappingTree.accept(mappingWriter)
            }
        }
    }

    def V1UpstreamedTask = tasks.register("${mcVersion}_toV1Upstream") {
        group = "V1 Upstream Conversion"
        inputs.file(v1MappingFile)
        outputs.file(v1UpstreamedMappingFile)

        doLast {
            def memoryMappingTree = new MemoryMappingTree()
            def reorder = new MappingDstNsReorder(memoryMappingTree, "clientOfficial", "serverOfficial")
            def renamer = new MappingNsRenamer(reorder, ["client": "clientOfficial", "server": "serverOfficial"])
            MappingReader.read(v1MappingFile.toPath(), renamer)
            try (def mappingWriter = MappingWriter.create(v1UpstreamedMappingFile.toPath(), MappingFormat.TINY_FILE)) {
                memoryMappingTree.accept(mappingWriter)
            }
        }
    }

    def V2UpstreamedTask = tasks.register("${mcVersion}_toV2Upstream") {
        group = "V2 Upstream Conversion"
        inputs.file(v2MappingFile)
        outputs.file(v2UpstreamedMappingFile)
        dependsOn(conversionTask)

        doLast {
            def memoryMappingTree = new MemoryMappingTree()
            def reorder = new MappingDstNsReorder(memoryMappingTree, "clientOfficial", "serverOfficial")
            def renamer = new MappingNsRenamer(reorder, ["client": "clientOfficial", "server": "serverOfficial"])
            MappingReader.read(v2MappingFile.toPath(), renamer)
            try (def mappingWriter = MappingWriter.create(v2UpstreamedMappingFile.toPath(), MappingFormat.TINY_2_FILE)) {
                memoryMappingTree.accept(mappingWriter)
            }
        }
    }

    def makeV1Jar = makeJar(mcVersion, v1MappingFile, false, false, {})
    def makeV2Jar = makeJar(mcVersion, v2MappingFile, true, false, {it.dependsOn(conversionTask) })
    def makeUpstreamV1Jar = makeJar(mcVersion, v1UpstreamedMappingFile, false, true, {it.dependsOn(V1UpstreamedTask) })
    def makeUpstreamV2Jar = makeJar(mcVersion, v2UpstreamedMappingFile, true, true, {it.dependsOn(V2UpstreamedTask) })

    publishing {
        publications {
            def publishName = "${mcVersion.replace(" ", "_")}"
            create(publishName, MavenPublication) {
                artifactId artifactVersion
                artifact(makeV1Jar)
                artifact(makeV2Jar) {
                    classifier = "v2"
                }
            }
            create(publishName + "-upstream", MavenPublication) {
                artifactId artifactVersion + "-upstream"
                artifact(makeUpstreamV1Jar)
                artifact(makeUpstreamV2Jar) {
                    classifier = "v2"
                }
            }
        }
    }
}

def makeJar(String version, File mappings, boolean v2, boolean upstreamed, Action<Jar> configure) {
    def jarFilename = "intermediary-" + (upstreamed ? "upstream-" : "") + version + (v2 ? "-v2" : "")
    return tasks.register("${version}_makeJar" + (v2 ? "v2" : "") + (upstreamed ? "Upstream" : ""), Jar) {
        archiveBaseName = jarFilename
        from(file(mappings)) {
            into "mappings"
            rename mappings.name, "mappings.tiny"
        }
        destinationDirectory = file("build/jars")
        configure(it)
    }
}

publishing {
    repositories {
        if (ENV.MAVEN_URL) {
            maven {
                url ENV.MAVEN_URL
                credentials {
                    username ENV.MAVEN_USERNAME
                    password ENV.MAVEN_PASSWORD
                }
            }
        }

        if (ENV.GITHUB_TOKEN) {
            maven {
                name = "GitHubPackages"
                url = "https://maven.pkg.github.com/Adventurecraft-Awakening/babric-intermediary"
                credentials {
                    username = ENV.GITHUB_ACTOR
                    password = ENV.GITHUB_TOKEN
                }
            }
        }
    }
}