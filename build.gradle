import net.fabricmc.mappingio.*
import net.fabricmc.mappingio.adapter.*
import net.fabricmc.mappingio.format.*
import net.fabricmc.mappingio.tree.*

buildscript {
    repositories {
        maven {
            name "Fabric Repository"
            url 'https://maven.fabricmc.net'
        }
    }

    dependencies {
        classpath 'net.fabricmc:mapping-io:0.6.1'
    }
}

plugins {
    id 'java'
    id 'maven-publish'
}

def ENV = System.getenv()

def localMappingsPath = "$buildDir/v2Mappings"
def localv1UpstreamedMappingsPath = "$buildDir/v1UpstreamMappings"
def localv2UpstreamedMappingsPath = "$buildDir/v2UpstreamMappings"

new File(localMappingsPath).mkdirs()
new File(localv1UpstreamedMappingsPath).mkdirs()
new File(localv2UpstreamedMappingsPath).mkdirs()

file('mappings').eachFile {
    if (!it.name.endsWith(".tiny")) return

    def mcVersion = it.name.replace(".tiny", "")

    def artifactVersion = mcVersion
    if (ENV.GITHUB_REF_NAME)
        artifactVersion += "+" + ENV.GITHUB_REF_NAME

    project.logger.lifecycle("Building ${artifactVersion}")

    File v1MappingFile = it
    File v2MappingFile = new File("$localMappingsPath/${it.name}")
    File v1UpstreamedMappingFile = new File("$localv1UpstreamedMappingsPath/${it.name}")
    File v2UpstreamedMappingFile = new File("$localv2UpstreamedMappingsPath/${it.name}")

    def conversionTask = "convert${it.name}ToV2"
    tasks.register(conversionTask) {
        group = "V2 Conversion"
        inputs.file(v1MappingFile)
        outputs.file(v2MappingFile)

        doLast {
            def memoryMappingTree = new MemoryMappingTree()
            def nsCompleter = new MappingNsCompleter(memoryMappingTree, Map.of("glue", "intermediary", "server", "intermediary", "client", "intermediary"));
            MappingReader.read(v1MappingFile.toPath(), nsCompleter)
            try (MappingWriter mappingWriter = MappingWriter.create(v2MappingFile.toPath(), MappingFormat.TINY_2_FILE)) {
                memoryMappingTree.accept(mappingWriter)
            }
        }
    }

    def V1UpstreamedTask = "toV1Upstream"
    tasks.register(V1UpstreamedTask) {
        group = "V1 Upstream Conversion"
        inputs.file(v1MappingFile)
        outputs.file(v1UpstreamedMappingFile)

        doLast {
            def memoryMappingTree = new MemoryMappingTree()
            def reorder = new MappingDstNsReorder(memoryMappingTree, "clientOfficial", "serverOfficial")
            def renamer = new MappingNsRenamer(reorder, ["client": "clientOfficial", "server": "serverOfficial"])
            MappingReader.read(v1MappingFile.toPath(), renamer)
            try (def mappingWriter = MappingWriter.create(v1UpstreamedMappingFile.toPath(), MappingFormat.TINY_FILE)) {
                memoryMappingTree.accept(mappingWriter)
            }
        }
    }

    def V2UpstreamedTask = "toV2Upstream"
    tasks.register(V2UpstreamedTask) {
        group = "V2 Upstream Conversion"
        inputs.file(v2MappingFile)
        outputs.file(v2UpstreamedMappingFile)
        dependsOn(conversionTask)

        doLast {
            def memoryMappingTree = new MemoryMappingTree()
            def reorder = new MappingDstNsReorder(memoryMappingTree, "clientOfficial", "serverOfficial")
            def renamer = new MappingNsRenamer(reorder, ["client": "clientOfficial", "server": "serverOfficial"])
            MappingReader.read(v2MappingFile.toPath(), renamer)
            try (def mappingWriter = MappingWriter.create(v2UpstreamedMappingFile.toPath(), MappingFormat.TINY_2_FILE)) {
                memoryMappingTree.accept(mappingWriter)
            }
        }
    }

    Jar makeV1Jar = makeJar(mcVersion, v1MappingFile, false, false)
    Jar makeV2Jar = makeJar(mcVersion, v2MappingFile, true, false)
    Jar makeUpstreamV1Jar = makeJar(mcVersion, v1UpstreamedMappingFile, false, true)
    Jar makeUpstreamV2Jar = makeJar(mcVersion, v2UpstreamedMappingFile, true, true)

    makeV2Jar.dependsOn conversionTask
    makeUpstreamV1Jar.dependsOn V1UpstreamedTask
    makeUpstreamV2Jar.dependsOn V2UpstreamedTask

    publishing {
        publications {
            def publishName = "${mcVersion.replace(" ", "_")}"
            create(publishName, MavenPublication) {
                groupId "babric"
                artifactId "intermediary"
                version artifactVersion
                artifact(makeV1Jar.archiveFile) {
                    builtBy makeV1Jar
                }
                artifact(makeV2Jar.archiveFile) {
                    builtBy makeV2Jar
                    classifier = "v2"
                }
            }
            create(publishName + "-upstream", MavenPublication) {
                groupId "babric"
                artifactId "intermediary-upstream"
                version artifactVersion
                artifact(makeUpstreamV1Jar.archiveFile) {
                    builtBy makeUpstreamV1Jar
                }
                artifact(makeUpstreamV2Jar.archiveFile) {
                    builtBy makeUpstreamV2Jar
                    classifier = "v2"
                }
            }
        }
    }
}

def makeJar(String version, File mappings, boolean v2, boolean upstreamed) {
    def jarFilename = "intermediary-" + (upstreamed ? "upstream-" : "") + version + (v2 ? "-v2" : "")
    return tasks.create("${version}_makeJar" + (v2 ? "v2" : "") + (upstreamed ? "Upstream" : ""), Jar) {
        archiveBaseName = jarFilename
        from(file(mappings)) {
            into "mappings"
            rename mappings.name, "mappings.tiny"
        }
        destinationDirectory = file("build/jars")
    }
}

publishing {
    repositories {
        if (ENV.MAVEN_URL) {
            maven {
                url ENV.MAVEN_URL
                credentials {
                    username ENV.MAVEN_USERNAME
                    password ENV.MAVEN_PASSWORD
                }
            }
        }

        if (ENV.GITHUB_TOKEN) {
            maven {
                name = "GitHubPackages"
                url = "https://maven.pkg.github.com/Adventurecraft-Awakening/babric-intermediary"
                credentials {
                    username = ENV.GITHUB_ACTOR
                    password = ENV.GITHUB_TOKEN
                }
            }
        }
    }
}
